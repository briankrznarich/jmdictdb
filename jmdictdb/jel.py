#######################################################################
#  This file is part of JMdictDB.
#  Copyright (c) 2019 Stuart McGraw
#
#  JMdictDB is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published
#  by the Free Software Foundation; either version 2 of the License,
#  or (at your option) any later version.
#
#  JMdictDB is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with JMdictDB; if not, write to the Free Software Foundation,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#######################################################################

# We provide a simplified interface to the JEL parser generated by
# the Ply parser-generator module as an alternative to calling the
# Ply functions directly.
#
# This module also contains functions for parsing "extended JEL"
# syntax -- JEL syntax that provides for specifying some additional
# metadata for the resulting entries.  It is primarily used for
# creating entries for tests.

import sys, re, pdb
from . import jdb, jellex, jelparse, logger; from logger import L
from .objects import *

class ParseError (ValueError): pass

# The following JelParser class is intended to simplify the code needed
# to parse JEL text.  An example of use:
#   dbcursor = jdb.dbOpen ('jmdict')
#   jeltxt = 'あ[1] ah'
#   parser = JelParser (dbcursor, 1, 2, False)
#   entr = parser.parse (jeltxt, src=1)

class JelParser:
        def __init__(self, dbcursor=None,
                           src=None, stat=None, unap=None,
                           debug=False):
              # 'dbcursor' is an open JMdictDB cursor such as returned
              # by jdb.dbOpen() and used when resolving any xrefs in the
              # parsed entry.  It is not required if .parse() wil be
              # called with 'resolve' set to false.
              # 'src', 'stat' and 'unap' are defaults value to use in
              # the Entr objects if values weren't supplid in the JEL
              # text.
              # NOTE: while 'dbcursor' is optional here, jdb.dbOpen()
              # *must* be called prior to executing .parse() since the
              # latter requires the jdb.KW structure to be initialized,
              # which jdb.dbOpen() does.

            self.lexer, tokens = jellex.create_lexer ()
            self.parser = jelparse.create_parser (self.lexer, tokens)
            self.dbcursor = dbcursor
            self.src = src
            self.stat = stat
            self.unap = unap
            self.debug = debug
        def parse (self, jeltext, resolve=True, dbcursor=None):
            jellex.lexreset (self.lexer, jeltext)
              #FIXME? why do we give the jeltext to both the lexer
              # and the parser?  One of the other should be sufficient.
            entr = self.parser.parse (debug=self.debug)
            if not entr.src: entr.src = self.src
            if not entr.stat: entr.stat = self.stat
            if not entr.unap: entr.unap = self.unap
            if resolve:
                if not dbcursor: dbcursor = self.dbcursor
                if not dbcursor: raise RuntimeError (
                    "Xref resolution requested but no database available")
                jdb.xresolv (dbcursor, entr)
            return entr

# The following functions are for parsing "extended JEL syntax"
#-----------------------------------------------------------------------------
# Extended JEL syntax description:
# - An entry starts with two characters "--", no leading whitespace
#     allowed.
# - May optionally be followed a comment (starting with "#") or zero or
#     more comment lines starting with "#" characters, possibly preceeded
#     with whitespace (ascii space, jp space (U+3000) or tab).
# - May be optionally followed by entry meta-data.  Each of these is
#     optional but if any are given, 'seq-number' must be given.  A
#     seq-number value of 0 is equivalent to no sequence number and
#     may be used if the seq-number is provided only to satisfy the
#     syntax requirement.
#     - sequence number.
#     - corpus name or id number.
#     - status: one of "a" (active), "r" (rejected), "d" (deleted).
#         May be either lower or upper case.
#     - unap: 'status' should be suffixed with "*" (no intervening space)
#         to denote an unapproved entry.
#     - other entry attributes (id, dfrm, etc) can be given as key=value
#         pairs, separated with semi-colons (;) inside square brackets.
#         Attributes may include seq#, corpus (named "src" as an attribute),
#         etc.:
#            1449070 [stat=2; unap=1]
#         is the same as
#            1449070 A*
#         If conflicting values are given ("1449070 test [src=1]") a
#         warning message is printed and the value inside the brackets
#         is used.
# - The remainder of the entry is the JEL text for the entry and has two
#     of three parts: kanji, reading, and sense.  The kanji part may be
#     omitted.  The JEL text can be in either of two forms: formfeed-
#     delimited or lf-delimited.
#   - If there are any '\f' characters (displayed as '\x0c' in Python) in
#     the text it is formfeed-delimited.  Otherwise it is lf-delimited.
#   - If formfeed-delimited:
#     - The kanji, reading and sense parts are separated by '\f' characters
#       and adjacent '\n' characters are ignored when distinguishing between
#       sections.  The kanji or reading part may be omitted.
#   - If lf-delimited:
#     - The kanji section must start on the line following the metainfo
#       line(s) and must be represented by a blank line if not present.
#     - The reading line must follow the kanji line and must be represented
#       by a blank line if not present.
#     - The sense(s) start on the third line (may use multiple lines).
# - The JEL text may be followed by blank lines.
#
# FIXME: need syntax for entr notes, groups
#
# Examples:
# The following example (between the triple-quotes) is parsable as-is.
# Note that some of these entries contain embedded form-feed characters
# (ascii dec:12, oct:14, hex:0C) that will display differently in different
# editors.  They may be shown as \f, ^L, 0x0c 000C, FF, \12, \014 or
# not at all (eg in VScode with "Render Control Characters" off).
#=============================================================================
Test = '''\
# The following entry is lf-delimited with each section (kanji,
# readings, senses) on separate lines.  There is no meta-info
# (seq number, etc) section.
-- 宿題　
   しゅくだい
   [1][n] homework

# This entry is the same as above but ff-delimited.
-- 宿題　 しゅくだい  [1][n] homework
#
# The corpus id, status id and/or approval status can be
# specified.  Each part is optional except seq-number and
# that can be 0 to specify a "don't care" value.
-- 3000120 jmdict A*
    宿題　 しゅくだい  [1][n] homework; assigned home study

# A typical jmdict entry with tags.
-- 1250220
形[ichi1,news1,nf01]；容；貌
かたち[ichi1,news1,nf01]；よう[容]
[1][n]
  [restr=形; 容]
  form; shape; figure
[2][n]
  visage
  [see=1217730・顔[1]]

# lf-delimited with no kanji.  The line for kanji must be
# be present and blank.
-- 300050

  アルバイト
  [1] part-time job

--

  アルバイト
  [1] part-time job

-- 300051   # The same but ff-delimited.  Note that if there is
            # only one kanji or reading part, the one assumed missing
            # is specified when the jel is parsed.  We asume here that
            # the parser is configured to assume the kanji part is
            # missing.  Better, simply avoid the ambiguity by preceeding
            # the reading part with a \f character.
  アルバイト[1] part-time job

# Additional entry attributes can be given in square brackets.  The seq#
# corpus# ("src"), state ("stat") and approval ("unap") can also be given
# as attributes and take priority over the equivalent values outside the
# brackets.
 
--1449070 A* [dfrm=43269; src=1]
当事[news1]
とうじ[news1]
[1][n] matter under concern
'''
#============================================================================

def parse (source, jelparser, resolve=True):
        '''-------------------------------------------------------------------

        Parameters:
          source -- An iterable that yields lines of extended JEL text.
            May a file object or list of text lines.
          jelparser -- A JelParser instance.
          resolve -- If true (default) try to resolve any unresolved xrefs
              in the loaded data.  #FIXME: just in the loaded data??
        Returns:
          A 2-tuple of lists:
            0: list of objects.Entr instances, one for each entry
               successfully parsed from 'data'.
            1: list of error messages, one for each entry parse failure.
        -------------------------------------------------------------------'''
        results = [];  errs = []
        for unitnum, (lnnum, unit) in enumerate (yield_jel_entry (source)):
            try:
                entr = jexparse (unit, unitnum, lnnum,
                                 jelparser, resolve=resolve)
            except (ParseError) as e:
                msg = "Parse error in JEL entry %d (starts at line %d): %s."\
                       % (unitnum+1, lnnum, str(e))
                errs.append (msg)
                continue
            results.append (entr)
        return results, errs

def yield_jel_entry (source):
        unit = [];  start_lnnum = 1; first = True
        for lnnum, ln in enumerate (source, start=1):
              # Lines may be coming from a file (with terminating "\n"s)
              # or from a list of text strings without.  Remove if present
              # for consistency.
            ln = ln.rstrip ("\n")
            if ln.startswith ("--"):
                ln = ln[2:]  # Remove leading hyphens.
                if first:
                      # Don't start new unit, continue accumulating
                      # lines in the initial unit.  This is to avoid
                      # creating a separate unit containing only comments
                      # that are before the first "--".
                    first = False
                else:
                    yield start_lnnum, "\n".join(unit)
                    unit = [];  start_lnnum = lnnum
            unit.append (ln)
        if unit: yield start_lnnum, '\n'.join(unit)
        return

def jexparse (text, entrnum, lnnum, jelparser, resolve=True):
        meta, jeltxt, warns = preparse (text)
        L('jel').debug("meta=%r" % meta)
        L('jel').debug("jel=%r" % jeltxt)
        if warns:
            L('jel').warn("Metainfo conflict(s) in entry"
                          " %d (starts at line %s):\n  %s"
                          % (entrnum+1, lnnum, "\n  ".join(warns)))
        try: entr = jelparser.parse (jeltxt, resolve=resolve)
        except jelparse.ParseError as e:
            raise ParseError (str(e))
        for k,v in meta.items():
            if v: setattr (entr, k, v)
        return entr

def preparse (jelex_txt, rprio=True):
          # Extract the extended JEL meta-info.
        meta, jeltxt, warns = metainfo (jelex_txt)
        parts = jeltxt.split ('\f')
        if len (parts) == 1:
              # No formsfeeds in text so the reading, kanji and
              # sense parts are separated by '\n's.
            try: kpart, rpart, spart = jeltxt.split ('\n', 2)
            except ValueError: raise ParseError (
              "Expected at least 3 lines in lf-delimited JEL, got %s."
              % len(parts))
        elif len (parts) == 2:
              # Parts are separated by '\f' characters but there
              # is only one reading/kanji part, not both.  We use
              # the value of 'rprio' to decide which it is.
            if rprio: kpart,rpart = '', parts[0].strip()
            else: kpart,rpart = parts[0].strip(), ''
            spart = parts[1].strip()
        elif len (parts) == 3:
              # Parts are separated by '\f' characters and there
              # are both reading and kanji parts.
            kpart, rpart, spart = [x.strip() for x in parts]
        else:
            raise ParseError ('Too many formfeeds.  Perhaps multiple '
               'entries got combined?  No whitespace allowed before '
               'the "--" characters.')
        jel = '\f'.join ([kpart, rpart, spart])
        return meta, jel, warns

def metainfo (jeltxt):
        # Separate the extended JEL meta-info, the main JEL text,
        # and comments.  Return the meta-info and JEL text and dump
        # the comments.
        src = stat = unap = None
        stat_abbrs = ''.join ([k for k in jdb.KW.STAT.keys()
                               if isinstance(k,str)])
          # This pattern will match the extended jel meta info.  Everything
          # following what it matches is the standard jel text.  Note that
          # although comment "#" lines are allowed in the meta-info, blank
          # lines aren't (because they are significant in lf-delimited jel.)
          # Blank lines are allowed after the end of the jel text and before
          # the next "--" however.
        pattern = r'''
          [ \t\u3000]*(?:\#[^\n]*\n)*  # Zero or more non-blank comment lines.
          [ \t\u3000]*(\d+)?         # Seq number. (1)
          [ \t\u3000]*((?:[a-z_][a-z0-9._-]+)|(?:\d+))?  # Corpus name. (2)
          [ \t\u3000]*([%s][*]?)?    # Stat and unap. (3)
          [ \t\u3000]*(\[.*?\])?     # Other stuff (id, dfrm, etc).(4)
          [ \t\u3000]*(?:\#[^\n]*)?  # Optional comment on seq line.
          \n?                  # JEL may start on same line or next.''' \
          % stat_abbrs         # \u3000 above is a jp wide space character.
        mo = re.match (pattern, jeltxt, re.DOTALL|re.I|re.X)
        if not mo: raise ParseError ("Bad syntax")
        seqt, corpt, statt, attrs = mo.group (1,2,3,4)
        seq = (seqt and int(seqt)) or None
        if corpt:
            try: src = int(corpt)
            except ValueError:
                try: src = jdb.KW.SRC[corpt].id
                except KeyError:
                    raise ParseError("Unknown corpus: %s" % corpt)
        if statt:
            unap = bool (statt.endswith('*'))
            stat = jdb.KW.STAT[statt.upper()[:-int(unap)]].id
        meta = parse_attrs (attrs)  # 'meta' is a dict.
        warns = []
          # Merge the values metainfo values from 'seq', 'src', 'stat'
          # and 'unap' into the values given inside the brackets (if any)
          # which are now in 'meta'.  The items within the brackets can
          # also specify seq, src, et.al., so we check and generate a
          # warning (and use the value inside the brackets) if there are
          # conflicting values.
        for k,v in (('seq',seq),('src',src),('stat',stat),('unap',unap)):
            if v:
                if k in meta and meta[k] != v:
                    warns.append ("'%s' value conflict, using %s"
                                  % (k, meta[k]))
                else: meta[k] = v
        t = jeltxt[mo.end():]
          # Remove any remaining trailing comments.
          #FIXME? this will also remove comments within the body of
          # the JEL text but this is an unintended side effect, not
          # an intentional feature.
        jtxt = re.sub (r'^(?:\s*)?(?:#.*)?$', '', t, flags=re.M)
        return meta, jtxt, warns

def parse_attrs (s):
        if not s: return {}
        if not s.startswith('[') or not s.endswith(']'):
            raise ValueError (s)
        items = re.split (r'(?<!\\);', s[1:-1])
        attrs = {}
        for item in items:
            k, v = item.split ('=', 1)
            k = k.strip()
            if k in ('id', 'dfrm', 'seq', 'src'): v = int(v)
            elif k in ('srcnote', 'notes'):
                  # This bit of magic is intended to convert any escaped
                  # characters like r'\n' (2 characters, backslash and "n")
                  # in 'v' into their unescaped form, '\n' (one character,
                  # a newline).  From:
                  #   https://stackoverflow.com/questions/4020539/
                  #     process-escape-sequences-in-a-string-in-python
                v = bytes(v, "utf-8").decode("unicode_escape")
            else: raise KeyError ("Unsupported entry attribute name: %s" % k)
            attrs[k] = v
        return attrs

def dbload (source, dbcursor, src=1, stat=2, unap=False):
        '''-------------------------------------------------------------------
        Load multiple entries from a file using Extended JEL format into
        a database.
        Parameters:
          source (file or list(str)) -- An open file, a list of str's
            or some other iterable that yields lines of text.
            The text describes entries in extended JEL format.
          dbcursor -- An open JMdictDB database cursor object such as
            returned from jdb.dbOpen().
          src, stat, unap -- Default values for Entr.src, .stat and .unap
            that will be used for each created Entr object if values are
            not given in the JEL text.
        -------------------------------------------------------------------'''
        parser = JelParser (dbcursor, src=src, stat=stat, unap=unap)
        entrs, errs = parse (source, parser)
        if errs: return [], errs
        added = []
        for e in entrs:
            r = jdb.addentr (dbcursor, e)
              # r is a 3-tuple of (entry-id#, seq#, src#)
            added.append (r)
        return added, []

def main():
        import fmtjel
        logger.log_config (level="debug")
        dbcursor = jdb.dbOpen ('jmdict')
        p = JelParser (dbcursor)
        data = Test.split("\n")  # Can't use .splitlines() because
                                 #  it splits on "\f" too.
        entrs, errs = parse (data, p)
        for e in entrs:
            print (e)
            print ("\n-- %s" % fmtjel.entr (e))
        if errs:
            print ("*** Parse failures ***")
            for err in errs: print (err)
        #pdb.set_trace()

if __name__ == '__main__': main()
