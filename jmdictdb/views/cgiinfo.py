# Copyright (c) 2020 Stuart McGraw
# SPDX-License-Identifier: GPL-2.0-or-later

# This web page will show some details about the WSGI/Python execution
# environment and is useful for diagnosing library location confusions.

# WARNING: The page generated by this view will show all items from the
# config.ini files, including those in the config-pvt.ini file (other
# than the db_* sections what are optionally supressed).

# NOTE: The Execution section will show the active wsgi file if that
# information is available.  To make it available, the wsgi file should
# contain a line like:
#   sys.wsgi_file = __file__   # See comments in views/cgiinfo.py.

# NOTE: This view is executed by the normal JMdictDB framework which
# means the configuration file(s) are read a startup and not when this
# page is refreshed.  To make config file changes visible to this view,
# depending on the WSGI server being used, restart the Flask runner or
# trigger an Apache mod_wsgi restart by 'touch'ing  the .wsgi file.

# NOTE: This view returns raw HTML rather than data to be rendered
# via a Jinja template so that failures in the Jinja rendering  code
# will not prvent this page from displaying.

#FIXME: The import error catching is a relic of the CGI version and can
# probably be removed.  Since this is view that requires the rest of the
# JMdictDB framework to be running, things will never get far enough to
# execute this page if imports of jmdictdb, jmcgi, db, etc fail.

import sys, configparser, html, os, pdb
try: import pkgpath.py  # Make jmdictdb package available on sys.path.
except ImportError: pass

Row_tmpl = "    <tr><td>%s</td><td>%s</td></tr>"

  # The following import checking code is inherited from the CGI version
  # and is left in place but is fairly worthless since all these imports
  # are required by flaskapp to run and we can only get called if flaskapp
  # is running.
jmdictdb = jdb = config = jmcgi = dbver = None
Failed_import = None
  # Following imports are in order of depencies: if import of jmdictdb fails,
  # a the following ones will fail too; if jdb fails, so won't config ands
  # jmcgi.  So no point trying a later import if earlier one fails and we
  # need only record the name of the first to fail.
try: import jmdictdb
except ImportError: Failed_import = 'jmdictdb'
if not Failed_import:
    try: from jmdictdb import db
    except ImportError: Failed_import = 'db'
if not Failed_import:
    try: from jmdictdb import jdb
    except ImportError: Failed_import = 'jdb'
if not Failed_import:
    try: from jmdictdb import config
    except ImportError: Failed_import = 'config'
if not Failed_import:
    try: from jmdictdb import jmcgi
    except ImportError: Failed_import = 'jmcgi'
if not Failed_import:
    try: from jmdictdb import dbver
    except ImportError: Failed_import = 'dbver'

def view (app, params):
        '''-------------------------------------------------------------------
        app_config -- The value of the Flask.Application instance's
                      .config attribute.
        params -- URL parameters from the HTTP request.  Not currently used.
        -------------------------------------------------------------------'''
        ex_rows = gen_ex_section()
        cfg_rows = gen_cfg_section (app)
        db_rows  = gen_db_section (app)
        app_rows = gen_app_section (app)
        env_rows = gen_env_section()
        htmltxt = Page % (ex_rows, cfg_rows, db_rows, app_rows, env_rows)
        return htmltxt

  # NOTE: Be mindful of the distinction between cfg.get()
  # and cfg_get() below.

def gen_ex_section():
        exdata = []
        exdata.append (('cwd', os.getcwd()))
        exdata.append (('cgi location',
                     os.path.dirname (os.path.abspath (__file__))))
        exdata.append (('python version', '%s' % sys.version))
        exdata.append (('sys.path', '%r' % sys.path))
        if jdb is not None:
            try: pkg_loc = os.path.dirname (os.path.abspath (jdb.__file__))
            except Exception as e: pkg_loc = e.__class__.__name__+": "+str(e)
            exdata.append (('pkg location', pkg_loc))
        else: exdata.append (('pkg location', "- (import of %s module failed)" % Failed_import))
        if jmdictdb is not None:
            try: pkg_ver =  getattr (jmdictdb, '__version__', '<none>')
            except Exception as e: pkg_ver = e.__class__.__name__+": "+str(e)
            exdata.append (('pkg version', pkg_ver))
        else: exdata.append (('pkg version', "- (import of %s module failed)" % Failed_import))
        if db is not None:
            dbvers = ', '.join ([("%.6x"%v) for v in dbver.DBVERS])
            exdata.append (('db reqd ver', dbvers))
        else:  exdata.append (('pkg version', "- (import of %s module failed)" % Failed_import))
        exdata.append (('wsgi file', getattr (sys, 'wsgi_file', '(n/a)')))
        ex_rows = '\n'.join ([Row_tmpl % (key.replace(' ','&nbsp;'), html.escape(value))
                              for key,value in exdata])
        return ex_rows

def gen_cfg_section (app):
        cfgdata, cfg = [], app.config['CFG']
        if Failed_import:
            cfgdata.append (('', "- (import of %s module failed)" % Failed_import))
        else:
            cfgdata.append (('config dir', cfg.get ('status', 'cfg_dir')))
            cfgdata.append (('config files',
                            cfg.get ('status', 'cfg_files')))
            cfgdata.append (cfg_get (cfg, 'logging', 'LOG_FILENAME'))
            cfgdata.append (cfg_get (cfg, 'web', 'STATUS_DIR'))
            cfgdata.extend (cfg_svcs (cfg))
        cfg_rows = '\n'.join ([Row_tmpl % (key.replace(' ','&nbsp;'),
                                           html.escape(value).replace("\n","<br>"))
                              for key,value in cfgdata])
        return cfg_rows

def gen_db_section (app):
        data, cfg = [], app.config['CFG']
        if Failed_import:
            data.append (('', "- (import of %s module failed)" % Failed_import))
        else:
              #FIXME: get data for the jmsess database too (though need to
              # decide about switching to a SQLite user database first.)
            data.extend (db_vers (cfg))
          # Use a 4-column row template instead of the 2-column 'Row_tmpl'
          #  one used by the other sections.
        rows = '\n'.join (["    <tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>"
                           % (svc.replace(' ','&nbsp;'),
                              sect.replace(' ','&nbsp;'),
                              html.escape(dburl).replace("\n","<br>"),
                              html.escape(updates).replace("\n","<br>"))
                           for svc,sect,dburl,updates in data])
        return rows

def gen_app_section (app):
        appdata = []
        appdata.append (('name', app.name))
        appdata.append (('root_path', app.root_path))
        appdata.append (('static_folder', app.static_folder))
        appdata.append (('static_url_path', app.static_url_path))
        appdata.append (('template_folder', app.template_folder))
        appdata.append (('instance_path', app.instance_path))
        app_rows = '\n'.join ([Row_tmpl % (key.replace(' ','&nbsp;'), value)
                              for key,value in appdata])
        return app_rows

def gen_env_section ():
        env_rows = '\n'.join ([Row_tmpl % (key.replace(' ','&nbsp;'), html.escape(value))
                              for key,value in sorted (os.environ.items())])
        return env_rows

def db_vers (cfg):
          # For each db service in cfg, get the corresponding database
          # update version number.  The database is accessed using the
          # username and password given for the service in the 'cfg'.
        dbdata = [('Svc_name ', ' Config_section ', ' DB_URL ', ' Updates')]
        cfgsects = [x for x in cfg.sections()
                   if x.startswith ('db_') and x!='db_session']
        for cfgsect in cfgsects:
            svcname = cfgsect[3:]   # Strip off the "db_" prefix.
            dbconn, updates, dburl, creds, missing = None, "", "", {}, []
              #FIXME: cfg[cfgsect]['dbname'] should be treated as a URL; we
              # treat it (as does JMdictDB code elsewhere) as the name of
              # a database on the local host.
            try: creds['dbname'] = dburl = cfg[cfgsect]['dbname']
            except KeyError: missing.append ('dbname')
            try: creds['user'] = cfg[cfgsect]['user']
            except KeyError: missing.append ('user')
            try: creds['password'] = cfg[cfgsect]['pw']
            except KeyError: missing.append ('pw')
            if not missing:
                try:
                    dbconn = db.open (creds)
                    updates = ", ".join(db.updates (dbconn))
                except Exception as e: updates = str(e)
                finally:  # Prevent resource leak.
                    if hasattr (dbconn, 'close'): dbconn.close()
            else:
                updates = "(config missing: %s)" % ",".join(missing)
            dbdata.append ((svcname, cfgsect, dburl, updates))
        return dbdata

def cfg_get (cfg, section, key):
        tag = "[%s] %s" % (section, key)
        try: value = cfg.get (section, key)
        except (configparser.NoSectionError, configparser.NoOptionError) as e:
            return tag, str(e)
        return tag, value

def cfg_svcs (cfg):
        results = [];  warns = []
        default_svc = cfg.get ('web', 'DEFAULT_SVC')
        results.append (('[web] DEFAULT_SVC', default_svc))
        svcs = [x[3:] for x in cfg.sections() if x.startswith ('db_')]
          # Report if 'db_session is missing but don't explicitly report
          # its presence.
        if 'session' in svcs: svcs.remove ('session')
        else: warns.append (('WARNING', "'session' not in svc's"))
        if default_svc not in svcs:
            warns.append (('WARNING', "default svc not in svc's"))
        results.append (("svc names", (', '.join(svcs))))
        return results + warns

  # Don't forget to double "%" characters below.
Page = '''<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>JMdictDB - Configuration details</title>
  <style>
    body         {font-family: arial;}
    .item        {background: #E8FFF0;
                 border-style: solid; border-width: thin;
                 margin: 5px; padding: 10px}
    .notes      {font-size: 75%%;}
    .err {color:red;} td {vertical-align: top;} .pre {white-space: pre;}
    </style>
  </head>
<body>
  <p>Execution info:
  <table class="item">
    %s
    </table>
  <p>Config info:<br>
  <table class="item">
    %s
    </table>
    <span class="notes">Note: No <b>LOG_FILENAME</b> value means log
      output to stderr.</span>
  <p>Database info:<br>
  <table class="item">
    %s
    </table>
  <p>App info:<br>
  <table class="item">
    %s
    </table>
    <span class="notes">Note: <b>static_folder</b> is not revevant if
      static files are being served directly by the web server.</span>
  <p>Environment info:<br>
  <table class="item">
    %s
    </table>
'''
